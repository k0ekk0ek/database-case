#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

/* benchmark code copied from Wojciech Mu≈Ça's toys repository (BSD-2-Clause) */
#include <stdint.h>
#define RDTSC_START(cycles)                                             \
    do {                                                                \
        uint32_t cyc_high, cyc_low;                                     \
        __asm volatile("cpuid\n"                                        \
                       "rdtsc\n"                                        \
                       "mov %%edx, %0\n"                                \
                       "mov %%eax, %1" :                                \
                       "=r" (cyc_high),                                 \
                       "=r"(cyc_low) :                                  \
                       : /* no read only */                             \
                       "%rax", "%rbx", "%rcx", "%rdx" /* clobbers */    \
                       );                                               \
        (cycles) = ((uint64_t)cyc_high << 32) | cyc_low;                \
    } while (0)

#define RDTSC_STOP(cycles)                                              \
    do {                                                                \
        uint32_t cyc_high, cyc_low;                                     \
        __asm volatile("rdtscp\n"                                       \
                       "mov %%edx, %0\n"                                \
                       "mov %%eax, %1\n"                                \
                       "cpuid" :                                        \
                       "=r"(cyc_high),                                  \
                       "=r"(cyc_low) :                                  \
                       /* no read only registers */ :                   \
                       "%rax", "%rbx", "%rcx", "%rdx" /* clobbers */    \
                       );                                               \
        (cycles) = ((uint64_t)cyc_high << 32) | cyc_low;                \
    } while (0)

static __attribute__ ((noinline))
uint64_t rdtsc_overhead_func(uint64_t dummy) {
    return dummy;
}

uint64_t global_rdtsc_overhead = (uint64_t) UINT64_MAX;

#define RDTSC_SET_OVERHEAD(test, repeat)			                \
  do {								                                \
    uint64_t cycles_start, cycles_final, cycles_diff;		        \
    uint64_t min_diff = UINT64_MAX;				                    \
    for (unsigned i = 0; i < repeat; i++) {			                \
      __asm volatile("" ::: /* pretend to clobber */ "memory");	    \
      RDTSC_START(cycles_start);				                    \
      test;							                                \
      RDTSC_STOP(cycles_final);                                     \
      cycles_diff = (cycles_final - cycles_start);		            \
      if (cycles_diff < min_diff) min_diff = cycles_diff;	        \
    }								                                \
    global_rdtsc_overhead = min_diff;				                \
    printf("rdtsc_overhead set to %d\n", (int)global_rdtsc_overhead);     \
  } while (0)							                            \


/*
 * Prints the best number of operations per cycle where
 * test is the function call, answer is the expected answer generated by
 * test, repeat is the number of times we should repeat and size is the
 * number of operations represented by test.
 */
#define BEST_TIME(pre, test, test_name, repeat, size)                   \
    do {                                                                \
        if (global_rdtsc_overhead == UINT64_MAX) {                      \
           RDTSC_SET_OVERHEAD(rdtsc_overhead_func(1), repeat);          \
        }                                                               \
        printf("%-30s\t: ", test_name); fflush(stdout);                 \
        uint64_t cycles_start, cycles_final, cycles_diff;               \
        uint64_t min_diff = (uint64_t)-1;                               \
        uint64_t sum_diff = 0;                                          \
        for (size_t i = 0; i < repeat; i++) {                           \
            pre;                                                        \
            __asm volatile("" ::: /* pretend to clobber */ "memory");   \
            RDTSC_START(cycles_start);                                  \
            test;                                                       \
            RDTSC_STOP(cycles_final);                                   \
            cycles_diff = (cycles_final - cycles_start - global_rdtsc_overhead); \
            if (cycles_diff < min_diff) min_diff = cycles_diff;         \
            sum_diff += cycles_diff;                                    \
        }                                                               \
        uint64_t S = size;                                              \
        float cycle_per_op = (min_diff) / (double)S;                    \
        float avg_cycle_per_op = (sum_diff) / ((double)S * repeat);     \
        printf(" %8.3f cycle/op (best) %8.3f cycle/op (avg)\n", cycle_per_op, avg_cycle_per_op); \
 } while (0)

#define error(message) (void)(fprintf(stderr, message "\n")), exit(EXIT_FAILURE)

typedef struct nsd_rdata_atom nsd_rdata_atom_t;
struct nsd_rdata_atom {
  uint16_t *rdata;
};

typedef struct nsd_rr nsd_rr_t;
struct nsd_rr {
  nsd_rdata_atom_t *rdatas;
  uint16_t type;
  uint16_t rdata_count;
};

// limited list of formats
enum nsd_rdata_format {
  NSD_RDATA_FORMAT_DNAME,
  NSD_RDATA_FORMAT_LONG,
  NSD_RDATA_FORMAT_A,
  NSD_RDATA_FORMAT_UNKNOWN
};

typedef enum nsd_rdata_format nsd_rdata_format_t;

typedef struct nsd_rr_descriptor nsd_rr_descriptor_t;
struct nsd_rr_descriptor {
  uint16_t type;
//  uint32_t minimum, maximum; 
  uint8_t format[64];
};

#define TYPE_A (1)
#define TYPE_SOA (6)

// limited list of descriptors (A and SOA)
static const nsd_rr_descriptor_t nsd_rr_descriptors[7] = {
  { 0, { NSD_RDATA_FORMAT_UNKNOWN } },
  { TYPE_A, { NSD_RDATA_FORMAT_A } },
  { 0, { NSD_RDATA_FORMAT_UNKNOWN } },
  { 0, { NSD_RDATA_FORMAT_UNKNOWN } },
  { 0, { NSD_RDATA_FORMAT_UNKNOWN } },
  { 0, { NSD_RDATA_FORMAT_UNKNOWN } },
  { TYPE_SOA, { NSD_RDATA_FORMAT_DNAME, NSD_RDATA_FORMAT_DNAME,
                NSD_RDATA_FORMAT_LONG,  NSD_RDATA_FORMAT_LONG,
                NSD_RDATA_FORMAT_LONG,  NSD_RDATA_FORMAT_LONG,
                NSD_RDATA_FORMAT_LONG } },
};

typedef struct nsd_packet nsd_packet_t;
struct nsd_packet {
  uint8_t *tail;
  uint8_t octets[65535];
};

static size_t written = 0;

__attribute__((always_inline))
static inline int32_t write_to_packet(
  nsd_packet_t *packet, const void *octets, size_t length)
{
  memcpy(packet->tail, octets, length);
  packet->tail += length;
  return 0;
}

static const uint8_t foobar[] = { 9, 'f', 'o', 'o', 'b', 'a', 'r', 'b', 'a', 'z', 0 };

__attribute__((noinline))
static int32_t write_dname(
  const nsd_rdata_atom_t *atom, nsd_packet_t *packet)
{
  (void)atom;
  return write_to_packet(packet, foobar, sizeof(foobar));
}

__attribute__((noinline))
static int32_t write_binary(
  const nsd_rdata_atom_t *atom, nsd_packet_t *packet)
{
  return write_to_packet(packet, atom->rdata, 4); // IP and LONG are 4 bytes
                                                  // simple shortcut
}

__attribute__((noinline))
static int32_t write_rr_rdata(
  const nsd_rr_t *rr, nsd_packet_t *packet)
{
  packet->tail = packet->octets;
  if (rr->type != TYPE_A && rr->type != TYPE_SOA)
    return -1;

  size_t count = 0;
  int32_t error = 0;
  const nsd_rr_descriptor_t *descriptor = &nsd_rr_descriptors[rr->type];

  for (; !error && count < rr->rdata_count; count++) {
//    if (i >= maximum)
//      return -1;
    if (descriptor->format[count] == NSD_RDATA_FORMAT_DNAME)
      error = write_dname(&rr->rdatas[count], packet);
    else
      error = write_binary(&rr->rdatas[count], packet);
  }

  written += packet->tail - packet->octets;

  if (error)
    return error;
//  if (count < minimum)
//    return -1;
  return 0;
}


typedef struct nsd_fast_rr nsd_fast_rr_t;
struct nsd_fast_rr {
  uint16_t type;
  uint16_t rdlength;
  // rdata
};

__attribute__((always_inline))
static inline const uint8_t *nsd_rr_rdata(const nsd_fast_rr_t *rr)
{
  return (const uint8_t *)rr + sizeof(nsd_fast_rr_t);
}

static int32_t nsd_write_a_rdata(
  const nsd_fast_rr_t *rr, nsd_packet_t *packet)
{
  write_to_packet(packet, nsd_rr_rdata(rr), 4);
  return 0;
}

static int32_t nsd_write_soa_rdata(
  const nsd_fast_rr_t *rr, nsd_packet_t *packet)
{
  const uint8_t *rdata = nsd_rr_rdata(rr);
  write_to_packet(packet, foobar, sizeof(foobar));
  write_to_packet(packet, foobar, sizeof(foobar));
  write_to_packet(packet, rdata + 2 * sizeof(void*), rr->rdlength - 2 * sizeof(void*));
  return 0;
}

typedef int32_t(*nsd_rdata_writer_t)(const nsd_fast_rr_t *, nsd_packet_t *);

static const nsd_rdata_writer_t nsd_rr_writers[7] = {
  0, nsd_write_a_rdata, 0, 0, 0, 0, nsd_write_soa_rdata
};

__attribute__((noinline))
static int32_t write_fast_rr_rdata(
  const nsd_fast_rr_t *rr, nsd_packet_t *packet)
{
  packet->tail = packet->octets;
  if (rr->type != TYPE_A && rr->type != TYPE_SOA)
    return -1;
  int32_t error = nsd_rr_writers[rr->type](rr, packet);
  written += packet->tail - packet->octets;
  return error;
}


struct test_data {
  int count;
  nsd_rr_t **rrs;
  nsd_fast_rr_t **fast_rrs;
};

#define alloc_error() error("cannot allocate memory")

static size_t rr_size = 0;
static size_t fast_rr_size = 0;

static void *rr_malloc(size_t size)
{
  rr_size += size;
  return malloc(size);
}

static nsd_rr_t *generate_a_rr(void)
{
  nsd_rr_t *rr;
  if (!(rr = (nsd_rr_t*)rr_malloc(sizeof(*rr))) ||
      !(rr->rdatas = (nsd_rdata_atom_t*)rr_malloc(sizeof(*rr->rdatas) * 1)))
    alloc_error();
  uint32_t data = (uint32_t)random();
  if (!(rr->rdatas[0].rdata = (uint16_t*)rr_malloc(sizeof(uint16_t) + sizeof(data))))
    alloc_error();
  rr->type = TYPE_A;
  rr->rdata_count = 1;
  *rr->rdatas[0].rdata = (uint16_t)sizeof(data);
  memcpy(rr->rdatas[0].rdata + 1, &data, sizeof(data));
  return rr;
}

static nsd_rr_t *generate_soa_rr(void)
{
  nsd_rr_t *rr;
  if (!(rr = (nsd_rr_t*)rr_malloc(sizeof(*rr))) ||
      !(rr->rdatas = (nsd_rdata_atom_t*)rr_malloc(sizeof(*rr->rdatas) * 7)))
    alloc_error();
  rr->type = TYPE_SOA;
  rr->rdata_count = 7;
  rr->rdatas[0].rdata = NULL;
  rr->rdatas[1].rdata = NULL;
  for (size_t i=2; i < 7; i++) {
    uint32_t data = (uint32_t)random();
    if (!(rr->rdatas[i].rdata = (uint16_t*)rr_malloc(sizeof(uint16_t) + sizeof(data))))
      alloc_error();
    *rr->rdatas[i].rdata = (uint16_t)sizeof(data);
    memcpy(rr->rdatas[i].rdata + 1, &data, sizeof(data));
  }
  return rr;
}

static void *fast_rr_malloc(size_t size)
{
  fast_rr_size += size;
  return malloc(size);
}

static nsd_fast_rr_t *generate_fast_a_rr(void)
{
  nsd_fast_rr_t *rr;
  static const size_t size = sizeof(*rr) + 1 * sizeof(uint32_t);
  if (!(rr = (nsd_fast_rr_t*)fast_rr_malloc(size)))
    alloc_error();
  uint32_t data = (uint32_t)random();
  rr->type = TYPE_A;
  rr->rdlength = size - sizeof(*rr);
  uint8_t *rdata = ((uint8_t *)rr) + sizeof(*rr);
  memcpy(rdata, &data, sizeof(data));
  return rr;
}

static nsd_fast_rr_t *generate_fast_soa_rr(void)
{
  nsd_fast_rr_t *rr;
  static const size_t size = sizeof(*rr) + 2 * sizeof(void*) + 5 * sizeof(uint32_t);
  if (!(rr = (nsd_fast_rr_t*)fast_rr_malloc(size)))
    alloc_error();
  uint32_t data[5];
  data[0] = (uint32_t)random();
  data[1] = (uint32_t)random();
  data[2] = (uint32_t)random();
  data[3] = (uint32_t)random();
  data[4] = (uint32_t)random();
  rr->type = TYPE_SOA;
  rr->rdlength = size - sizeof(*rr);
  uint8_t *rdata = ((uint8_t *)rr) + sizeof(rr);
  memcpy(rdata, &data, sizeof(data));
  return rr;
}

static int32_t generate_test_data(struct test_data *test_data)
{
  uint16_t types[2] = { TYPE_A, TYPE_SOA };

  // use plain malloc here to avoid adding the memory to either method
  test_data->rrs = (nsd_rr_t**)malloc(sizeof(nsd_rr_t *) * test_data->count);
  test_data->fast_rrs = (nsd_fast_rr_t**)malloc(sizeof(nsd_fast_rr_t *) * test_data->count);

  if (!test_data->rrs || !test_data->fast_rrs)
    error("cannot allocate memory");

  for (size_t i = 0; i < test_data->count; i++) {
    uint16_t type = types[ random() % 2 ];
    if (type == TYPE_A) {
      test_data->rrs[i] = generate_a_rr();
      test_data->fast_rrs[i] = generate_fast_a_rr();
    } else {
      test_data->rrs[i] = generate_soa_rr();
      test_data->fast_rrs[i] = generate_fast_soa_rr();
    }
  }
  return 0;
}

int main(int argc, char *argv[])
{
  struct test_data test_data = { 1000000, NULL, NULL };

  pid_t pid = getpid();
  srandom(pid);

  if (argc > 1)
    test_data.count = atoi(argv[1]);

  if (generate_test_data(&test_data) != 0)
    error("cannot generate test data");

  printf("generated rr size: %zu\n", rr_size);
  printf("generated fast rr size: %zu\n", fast_rr_size);

  nsd_packet_t packet = { 0 };

  written = 0;
  BEST_TIME(/**/, write_rr_rdata(test_data.rrs[i], &packet), "rr", test_data.count, 1);
  printf("written: %zu\n", written);
  written = 0;
  BEST_TIME(/**/, write_fast_rr_rdata(test_data.fast_rrs[i], &packet), "fast_rr", test_data.count, 1);
  printf("written: %zu\n", written);

  return 0;
}
